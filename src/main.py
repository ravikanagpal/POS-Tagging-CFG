# -*- coding: utf-8 -*-
"""A2_NLP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O18oJH_GMYoij-dnPRzfGvCCDsbGQNKi
"""

# importing dependencies
import csv
import nltk
import codecs
import pandas as pd
import re 
import sys
from nltk import CFG
from nltk import load_parser

# to make the nltk interpret the PRP$ (i.e non terminal would accept the dollar sign), we have added the following. Data source: https://stackoverflow.com/questions/33207799/nltk-cant-interpret-grammar-category-prp-output-by-stanford-parser
nltk.grammar._STANDARD_NONTERM_RE = re.compile('( [\w/][\w$/^<>-]* ) \s*', re.VERBOSE)
# this rule is added for terminals to consider the double quotes. 
nltk.grammar._TERMINAL_REGEX = re.compile(r"(([\"\']) (?:\\\2|.)+?\2) \s*", re.VERBOSE)



#data source: https://www.kite.com/python/answers/how-to-read-a-tsv-file-in-python
# this method will take a traindata(argument passed by user that has the data path) and returns a dataframe of data by reading tsv file
def get_data(traindata):
  tsv_file = open(traindata)
  data = pd.read_csv(tsv_file, delimiter="\t")
  print(data.shape)
  return data
#data.head(20)

# reading toygrammar
def reading_grammar(toygrammar):
  with open(toygrammar, 'r')as f:
    t = f.readlines()
  return t

# using nltk load_parser to load the grammar (in the toy grammar file)

# this method will take a toygrammar( path of cfg grammar file), and then load the file and parser it with Chart Parser
def parsing_grammar(toygrammar):
  #cp = load_parser(toygrammar)
  rules = nltk.data.load(toygrammar, 'text')
  grammar = nltk.CFG.fromstring(rules)
  # we use NLTK chart parser presented here: https://docs.huihoo.com/nltk/0.9.5/en/ch08.html
  cp =  nltk.ChartParser(grammar)
  return cp


#data source: https://www.nltk.org/book/ch08.html
def get_results( cp, sentence):
  
  for index, row in data.iterrows():
    sentence = row['pos']
    wrong_syntax = True
    sent_split = sentence.split()
    print(sentence)
    # parsing the sentences (in this case POS tag) using the grammar rules, if tree exists the before code will run otherwise the if condition where wrong_syntax == 1 will run. 
    #print(type(cp.parse(sent_split)))
    # using the fact that the parser wouldn't be able to parse the incorrect grammar, so we made an if:else condition to know if the there exist a parser for a sentence. 
    if (len(list(cp.parse(sent_split))) > 0):
      # if grammar is correct, we append the label 0
      results.append((row['id'], row['label'], 0))
      print(row['id'], "Correct Grammer !!!")
    else:
      results.append((row['id'], row['label'], 1)) 
      # incorrect grammar have label 1 
      print(row['id'], "Incorrect Grammer!!!!")
    
  return results


# codet to get the id, ground_truth and prediction
def save_results(results, resultfile):

  column_names = ["id", "ground_truth", "prediction"]
  df = pd.DataFrame(results, columns =column_names)
  # storing the results to tsv file
  df.to_csv( resultfile,index=False)
  return df




# finding false positive, true positive, true negative, false negatives
def find_mat(df):
  false_positive , false_negative = 0, 0
  true_positive, true_negative = 0, 0
  for index, row in df.iterrows():
    # if the ground truth is 0 (correct grammar) and predicted label is 1 (incorrect grammar) : False negative
    if row['ground_truth'] == 0 and row['prediction'] == 1:
      false_negative = false_negative+1
    # checks if the ground truth is 1 (incorrect grammar) and prediction is 0 (correct grammar): False positive
    if row['ground_truth'] == 1 and row['prediction'] == 0:
      false_positive = false_positive + 1
    # checks if the ground truth is 0 (correct grammar) and prediction is 0 (correct grammar): True positive
    if row['ground_truth'] == 0 and row['prediction'] == 0:
      true_positive = true_positive + 1
    # checks if the ground truth is 1 (incorrect grammar) and prediction is 1 (incorrect grammar): True negative
    if row['ground_truth'] == 1 and row['prediction'] == 1:
      true_negative = true_negative + 1

  print(" True positive are :" , true_positive)
  print(" False negative: ", false_negative)
  print(" False positive: ", false_positive)
  print(" True Negative: ", true_negative,)

  return true_positive, false_positive, false_negative, true_negative



# finding precision and recall using the formulas given in the assignment manual. 
def prec_recall(true_positive, false_positive, false_negative):
  precision = true_positive/(true_positive + false_positive)
  recall = true_positive/(true_positive + false_negative)
 
  return precision, recall




"""#### RUN TEST ####"""
# taking user arguments
traindata = sys.argv[1]
toygrammar = sys.argv[2]
resultfile = sys.argv[3]
results = []
# calling get_data method that will return a dataframe of data
data = get_data(traindata)
t = reading_grammar(toygrammar)
# parsing the toygrammar using the Chart Parser
cp = parsing_grammar(toygrammar)
# getting results by passing the parser and the data to get_results
results  = get_results(cp, sentence = data['pos'].tolist())
# results saved in resultfile (argument passed by user)
df = save_results(results, resultfile)
# finding TP, FN, FP, TN
true_positive, false_positive, false_negative, true_negative = find_mat(df)
# finding precision and recall
precision, recall = prec_recall(true_positive, false_positive, false_negative)
print("Precision ", precision)
print("Recall ", recall)
